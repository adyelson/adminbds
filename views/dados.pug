html
  head
    title Tabela Editável
    link(rel="stylesheet", href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css")
  body
    button(id="download-button") Download JSON
    button(id="insert-button") Inserir Linha
    table(id="editable-table")
      tr
        th Ação
        each key in keys
          th= key
      each item in data
        tr
          td
            button.delete-button(type="button") X
          each value in item
            td.content(contenteditable="true")= value

script.
  // JavaScript para tornar a tabela editável
  const table = document.getElementById("editable-table");
  const downloadButton = document.getElementById("download-button");
  let data = !{JSON.stringify(data)};
  let keys = !{JSON.stringify(keys)};

  table.addEventListener("input", (event) => {
    const td = event.target;
    const row = td.parentNode;
    const rowIndex = row.rowIndex - 1;
    const cellIndex = td.cellIndex - 1;
    
    data[rowIndex][keys[cellIndex]] = td.textContent;
  });

  table.addEventListener("click", (event) => {
    if (event.target.classList.contains("delete-button")) {
        console.log("DELETE");
      const row = event.target.parentNode.parentNode;
      const rowIndex = row.rowIndex - 1;
      data.splice(rowIndex, 1);
      row.remove();
    }
  });
  
  const jsonData = JSON.stringify(data);

  // Gere um nome de arquivo único, por exemplo, usando um timestamp
  const timestamp = Date.now();
  const fileName = `data_${timestamp}.json`;

  const formData = new FormData();
  formData.append("file", new Blob([jsonData], { type: "application/json" }), fileName);

  // Adicione um ouvinte de evento ao botão de download/upload
  downloadButton.addEventListener("click", () => {
    fetch("/upload-json-and-convert", {
      method: "POST",
      body: formData,
    })
      .then((response) => response.text()) // Recebe o texto formatado do servidor
      .then((formattedText) => {
        // Aqui você pode fazer algo com o texto formatado, se necessário
        console.log("Texto formatado recebido: " + formattedText);
      })
      .catch((error) => {
        console.error("Erro ao receber o texto formatado: " + error);
      });
  });


  // Código do cliente para enviar os dados JSON para o servidor
  //- downloadButton.addEventListener("click", () => {
  //-   // Supondo que 'data' contenha os dados JSON a serem enviados

  //-   // Envia os dados JSON para o servidor usando uma solicitação POST
  //-   fetch("/converter-e-enviar", {
  //-     method: "POST",
  //-     headers: {
  //-       "Content-Type": "application/json", // Define o tipo de conteúdo como JSON
  //-     },
  //-     body: JSON.stringify(data), // Converte a matriz de objetos JSON em uma string JSON
  //-   })
  //-   .then((response) => response.text()) // Recebe o texto formatado do servidor
  //-   .then((formattedText) => {
  //-     // Cria um arquivo Blob com o texto formatado
  //-     const blob = new Blob([formattedText], { type: "text/plain" });

  //-     // Cria uma URL para o Blob
  //-     const blobUrl = URL.createObjectURL(blob);

  //-     // Cria um elemento <a> para fazer o download
  //-     const a = document.createElement("a");
  //-     a.href = blobUrl;
  //-     a.download = "dados_formatados.txt"; // Nome do arquivo que será baixado
  //-     a.style.display = "none";

  //-     // Adiciona o elemento <a> ao corpo do documento
  //-     document.body.appendChild(a);

  //-     // Aciona o clique no elemento <a> para iniciar o download
  //-     a.click();

  //-     // Remove o elemento <a> do corpo do documento
  //-     document.body.removeChild(a);

  //-     // Libera a URL do Blob
  //-     URL.revokeObjectURL(blobUrl);
  //-   })
  //-   .catch((error) => {
  //-     console.error("Erro ao receber o texto formatado: " + error);
  //-   });
  //- });



  //- downloadButton.addEventListener("click", () => {
  //-   const updatedJson = JSON.stringify(data);
  //-   const blob = new Blob([updatedJson], { type: "application/json" });
  //-   const url = URL.createObjectURL(blob);
  //-   const a = document.createElement("a");
  //-   a.href = url;
  //-   a.download = "updated_data.json";
  //-   document.body.appendChild(a);
  //-   a.click();
  //-   document.body.removeChild(a);
  //- });




  // ...

    // Evento de clique no botão "Inserir Linha"
    const insertButton = document.getElementById("insert-button");
    insertButton.addEventListener("click", () => {
    // Crie uma nova linha vazia com o mesmo número de células que os cabeçalhos
    const newRow = table.insertRow(1); // Insere no início da tabela
    for (let i = 0; i < keys.length + 1; i++) { // +1 para a célula da ação
        const cell = newRow.insertCell(i);
        if (i === 0) {
        // Célula de ação com botão de exclusão
        const deleteButton = document.createElement("button");
        deleteButton.className = "delete-button";
        deleteButton.type = "button";
        deleteButton.textContent = "X";
        cell.appendChild(deleteButton);
        } else {
        // Célula de conteúdo editável com <div>
        const contentEditable = document.createElement("div");
        contentEditable.contentEditable = true;
        cell.appendChild(contentEditable);
        
        // Adicionar evento de input para atualizar os dados
        contentEditable.addEventListener("input", () => {
            const rowIndex = newRow.rowIndex - 1;

            // Verificar se o índice existe nas chaves e nos dados antes de atualizar
            if (keys[i - 1] && data[rowIndex]) {
            data[rowIndex][keys[i - 1]] = contentEditable.textContent;
            }
        });
        }
    }
    // Adicione um novo objeto vazio aos dados
    const newEmptyRow = {};
    keys.forEach((key) => {
        newEmptyRow[key] = "";
    });
    data.unshift(newEmptyRow);
    });

    // ...
